<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>以太 · 秘文终端 | Aether Cipher</title>

    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Lucide 图标库 -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- 引入 LZ-String 压缩库 -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

    <!-- 引入高雅字体 -->
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+JP:wght@300;500;700;900&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap"
        rel="stylesheet">

    <style>
        body {
            background-color: #020202;
            color: white;
            font-family: 'Noto Serif JP', serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        /* 自定义动画关键帧 */
        @keyframes spin-slow {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-20px);
            }
        }

        @keyframes pulse-glow {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-150%) skewX(-15deg);
            }

            100% {
                transform: translateX(150%) skewX(-15deg);
            }
        }

        @keyframes scan-down {
            0% {
                top: -10%;
            }

            100% {
                top: 110%;
            }
        }

        @keyframes blob-rotate {
            0% {
                transform: rotate(0deg) scale(1);
            }

            50% {
                transform: rotate(180deg) scale(1.3);
            }

            100% {
                transform: rotate(360deg) scale(1);
            }
        }

        /* 实用类 */
        .bloom-text {
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.4), 0 0 40px rgba(255, 255, 255, 0.2);
        }

        .glow-cyan {
            text-shadow: 0 0 10px rgba(6, 182, 212, 0.8);
        }

        .glow-red {
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
        }

        .liquid-blob {
            animation: blob-rotate 20s infinite linear;
        }

        .liquid-filter {
            filter: url(#liquid);
        }

        .writing-vertical {
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        /* 自定义滚动条样式（用于大文本显示） */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(6, 182, 212, 0.5);
            border-radius: 4px;
            transition: background 0.3s;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(6, 182, 212, 0.8);
        }

        /* Firefox 滚动条 */
        .custom-scrollbar {
            scrollbar-width: thin;
            scrollbar-color: rgba(6, 182, 212, 0.5) rgba(255, 255, 255, 0.05);
        }

        /* 隐藏滚动条 */
        ::-webkit-scrollbar {
            width: 0px;
        }

        /* 3D 透视 */
        .perspective-1000 {
            perspective: 1000px;
        }

        .preserve-3d {
            transform-style: preserve-3d;
        }

        /* 滑块动画类 */
        .slider-handle {
            transition: background-color 0.3s, transform 0.1s;
        }

        .slider-handle:active {
            cursor: grabbing;
        }
    </style>
</head>

<body class="selection:bg-cyan-500/30">

    <!-- SVG 滤镜定义 -->
    <svg style="position: absolute; width: 0; height: 0;">
        <defs>
            <filter id="liquid">
                <feTurbulence type="fractalNoise" baseFrequency="0.01 0.005" numOctaves="4" result="warp" />
                <feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="40" in="SourceGraphic" in2="warp" />
            </filter>
            <filter id="noiseFilter">
                <feTurbulence type="fractalNoise" baseFrequency="0.85" numOctaves="3" stitchTiles="stitch" />
            </filter>
        </defs>
    </svg>

    <!-- 背景层 -->
    <div id="background-layer" class="fixed inset-0 z-0 pointer-events-none transition-colors duration-1000">
        <div class="absolute inset-0 bg-[#050505]"></div>

        <!-- 流体光斑 -->
        <div id="fluid-blob"
            class="liquid-blob absolute -top-[50%] -left-[50%] w-[200%] h-[200%] blur-[120px] bg-gradient-to-r mix-blend-screen opacity-50 transition-colors duration-1000">
        </div>

        <!-- 液态扭曲层 -->
        <div class="absolute inset-0 opacity-40 mix-blend-overlay liquid-filter"
            style="background: radial-gradient(circle at center, transparent 30%, rgba(255,255,255,0.1) 60%, transparent 80%); animation: float 10s infinite linear;">
        </div>

        <!-- 噪点与网格 -->
        <div class="fixed top-0 left-0 w-full h-full opacity-[0.04] mix-blend-overlay"
            style="filter: url(#noiseFilter); background: white;"></div>
        <div class="absolute inset-0 opacity-[0.03]"
            style="background-image: linear-gradient(rgba(255,255,255,0.3) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.3) 1px, transparent 1px); background-size: 40px 40px; mask-image: radial-gradient(circle at center, black 40%, transparent 100%);">
        </div>
    </div>

    <!-- 应用主容器 -->
    <div id="app" class="relative z-10 w-full h-screen flex flex-col items-center justify-center">
        <!-- 内容将通过 JS 动态渲染 -->
    </div>

    <script>
        // ==========================================
        // 数据与常量
        // ==========================================
        const STYLES = [
            {
                id: "attackOnTitan",
                name: "进击的巨人",
                sub: "ATTACK ON TITAN",
                colorClass: "from-[#8B4513] via-[#A0522D] to-[#CD853F]",
                bgGradient: "linear-gradient(to right, #8B4513, #A0522D, #CD853F)",
                quote: "献出心脏",
                desc: "把巨人全部驱逐出去！为了自由而战斗！",
                icon: "shield"
            },
            {
                id: "fate",
                name: "Fate系列",
                sub: "FATE",
                colorClass: "from-[#FFB75E] via-[#ED8F03] to-[#FF3CAC]",
                bgGradient: "linear-gradient(to right, #FFB75E, #ED8F03, #FF3CAC)",
                quote: "无限剑制",
                desc: "此身为剑所成。理想已远，唯剑永存。",
                icon: "swords"
            },
            {
                id: "eva",
                name: "新世纪福音战士",
                sub: "EVANGELION",
                colorClass: "from-[#662D8C] via-[#ED1E79] to-[#00FF00]",
                bgGradient: "linear-gradient(to right, #662D8C, #ED1E79, #00FF00)",
                quote: "不可以逃避",
                desc: "AT力场全开。拒绝与渴望的螺旋，即是补完的尽头。",
                icon: "aperture"
            },
            {
                id: "steins",
                name: "命运石之门",
                sub: "STEINS;GATE",
                colorClass: "from-[#c89b3c] via-[#f0e68c] to-[#daa520]",
                bgGradient: "linear-gradient(to right, #c89b3c, #f0e68c, #daa520)",
                quote: "El Psy Kongroo",
                desc: "欺骗世界，连接唯一的真实。在这收束的因果彼方。",
                icon: "zap"
            },
            {
                id: "monogatari",
                name: "物语系列",
                sub: "MONOGATARI",
                colorClass: "from-[#FF0099] via-[#493240] to-[#FF0099]",
                bgGradient: "linear-gradient(to right, #FF0099, #493240, #FF0099)",
                quote: "怪异，就是你自己",
                desc: "告白即觉悟。怪异是内心的扭曲，幸福是主动的选择。",
                icon: "sparkles"
            },
            {
                id: "whiteAlbum2",
                name: "白色相簿2",
                sub: "WHITE ALBUM 2",
                colorClass: "from-[#E6F3FF] via-[#B8D4E8] to-[#FFFFFF]",
                bgGradient: "linear-gradient(to right, #E6F3FF, #B8D4E8, #FFFFFF)",
                quote: "梦里不觉秋已深",
                desc: "是我先来的……明明都是我先来的。",
                icon: "snowflake"
            },
            {
                id: "saenaiHeroine",
                name: "路人女主",
                sub: "SAENAI HEROINE",
                colorClass: "from-[#FF69B4] via-[#FFB6C1] to-[#FFC0CB]",
                bgGradient: "linear-gradient(to right, #FF69B4, #FFB6C1, #FFC0CB)",
                quote: "你要成为我的女主角",
                desc: "远的不是距离，而是次元。真正的幸福女主角。",
                icon: "heart"
            },
            {
                id: "jojo",
                name: "JOJO的奇妙冒险",
                sub: "JOJO",
                colorClass: "from-[#FFD700] via-[#FFA500] to-[#FF4500]",
                bgGradient: "linear-gradient(to right, #FFD700, #FFA500, #FF4500)",
                quote: "人类的赞歌就是勇气的赞歌",
                desc: "黄金的精神。欧拉欧拉！木大木大！",
                icon: "flame"
            },
            {
                id: "yourName",
                name: "你的名字",
                sub: "YOUR NAME",
                colorClass: "from-[#FF6B9D] via-[#C06C84] to-[#6C5B7B]",
                bgGradient: "linear-gradient(to right, #FF6B9D, #C06C84, #6C5B7B)",
                quote: "我在寻找，尚未谋面的你",
                desc: "黄昏之时，跨越时空的羁绊。君の名は。",
                icon: "heart-handshake"
            },
            {
                id: "mixed",
                name: "番剧混合",
                sub: "MIXED QUOTES",
                colorClass: "from-[#667eea] via-[#764ba2] to-[#f093fb]",
                bgGradient: "linear-gradient(to right, #667eea, #764ba2, #f093fb)",
                quote: "跨越次元的回响",
                desc: "汇聚所有番剧的经典台词，随机混合展现。",
                icon: "shuffle"
            }
        ];

        // 状态管理
        const state = {
            mode: 'ENCRYPT', // 'ENCRYPT' | 'DECRYPT'
            stage: 'LOCKED', // 'LOCKED' | 'PROCESSING' | 'RESULT'
            text: '',
            password: '',  // 加密密钥
            styleIndex: 0,
            language: 'cn',  // 'cn' | 'jp' 台词语言
            segmentMode: false,  // 🔥 分段模式开关
            resultData: null  // 存储加密结果
        };

        // DOM 元素引用
        const app = document.getElementById('app');
        const fluidBlob = document.getElementById('fluid-blob');

        // ==========================================
        // 台词库 - 中日双语版本（含角色出处）
        // ==========================================
        const quoteLibrary = {
            fate: [
                { jp: '「無限の剣製」', cn: '「无限剑制(Unlimited Blade Works)」', char: '卫宫士郎/Archer' },
                { jp: '「正義の味方になりたかった」', cn: '「我曾想成为正义的伙伴」', char: '卫宫士郎' },
                { jp: '「人は何度でも蘇る」', cn: '「人可以无数次重生」', char: '间桐樱' },
                { jp: '「この世全ての悪」', cn: '「此世全部之恶(Angra Mainyu)」', char: '间桐樱/安哥拉曼纽' },
                { jp: '「王の財宝」', cn: '「王之财宝(Gate of Babylon)」', char: '吉尔伽美什' },
                { jp: '「我が骨子は捻れ狂う」', cn: '「我的骨血已然扭曲狂乱」', char: '库·丘林(Alter)' },
                { jp: '「体は剣で出来ている」', cn: '「此身为剑所成」', char: '卫宫士郎/Archer' },
                { jp: '「理想を抱いて溺死しろ」', cn: '「心怀理想溺亡吧」', char: '卫宫切嗣' },
                { jp: '「問おう、貴方が私のマスターか」', cn: '「试问，你就是我的御主吗？」', char: '阿尔托莉雅' },
                { jp: '「全て遠き理想郷」', cn: '「远离尘世的理想乡(Avalon)」', char: '阿尔托莉雅' },
                { jp: '「約束された勝利の剣」', cn: '「誓约胜利之剑(Excalibur)」', char: '阿尔托莉雅' },
                { jp: '「騎英の手綱」', cn: '「骑英之缰绳(Bellerophon)」', char: '美杜莎' },
                { jp: '「偽・螺旋剣」', cn: '「伪·螺旋剑(Caledfwlch)」', char: '阿尔托莉雅' },
                { jp: '「我はここに誓う」', cn: '「我在此立誓」', char: '贞德' },
                { jp: '「そなたの願いを叶えよう」', cn: '「就让我来实现你的愿望吧」', char: '基尔什塔利亚' },
                { jp: '「君はただの剣ではない」', cn: '「你并非只是一把剑」', char: '卫宫士郎' },
                { jp: '「星に願いを」', cn: '「向星辰许愿」', char: '伊什塔尔' },
                { jp: '「王になる資格があるのは、王自身だけだ」', cn: '「拥有成王资格的，唯有王自身」', char: '吉尔伽美什' },
                { jp: '「救いたいのは、ただ一人の少女だ」', cn: '「我想拯救的，不过是一名少女而已」', char: '卫宫士郎' },
                { jp: '「愛すればこそ、奪われるのだ」', cn: '「正因为深爱，才会被夺走」', char: '间桐樱' }
            ],
            eva: [
                { jp: '「あなたは、そこにいますか？」', cn: '「你，就在那里吗？」', char: '绫波丽' },
                { jp: '「逃げちゃダメだ」', cn: '「不可以逃避」', char: '碇真嗣/葛城美里' },
                { jp: '「私は人形じゃない」', cn: '「我不是人偶」', char: '绫波丽' },
                { jp: '「碇くん、おはよう」', cn: '「碇君，早上好」', char: '绫波丽' },
                { jp: '「気持ち悪い」', cn: '「好恶心」', char: '碇真嗣' },
                { jp: '「全部ひとりでやれって言うの！？」', cn: '「你是说全部都要我一个人来做吗！？」', char: '明日香' },
                { jp: '「人類補完計画」', cn: '「人类补完计划」', char: 'SEELE/碇源堂' },
                { jp: '「ATフィールド全開」', cn: '「AT力场全开」', char: 'eva驾驶员通用' },
                { jp: '「サービスサービスぅ！」', cn: '「服务服务啦！」', char: '真希波' },
                { jp: '「パターン青、使徒です」', cn: '「蓝色模式，确认是使徒」', char: '葛城美里' },
                { jp: '「シンクロ率400%」', cn: '「同步率400%」', char: '碇真嗣' },
                { jp: '「暴走」', cn: '「暴走」', char: 'eva机体通用' },
                { jp: '「第三新東京市」', cn: '「第三新东京市」', char: '通用' },
                { jp: '「セカンドインパクト」', cn: '「第二次冲击」', char: '通用' },
                { jp: '「ゼーレのシナリオ通りに」', cn: '「按照SEELE的剧本进行」', char: '碇源堂' },
                { jp: '「おめでとう」', cn: '「恭喜你」', char: '渚薰' },
                { jp: '「絶対絶望少年」', cn: '「绝对绝望少年」', char: '渚薰' },
                { jp: '「魂を継ぐ者」', cn: '「继承灵魂之人」', char: '绫波丽' },
                { jp: '「苦しみを知ってこそ、人は強くなれる」', cn: '「唯有知晓痛苦，人才能变得强大」', char: '葛城美里' },
                { jp: '「俺は継ぐ者だ」', cn: '「我是继承者」', char: '碇真嗣' }
            ],
            steins: [
                { jp: '「エル・プサイ・コングルゥ」', cn: '「El Psy Kongroo（吾心吾行 澄如明镜 所作所为 皆属正义）」', char: '牧濑红莉栖' },
                { jp: '「世界線変動率」', cn: '「世界线变动率」', char: '通用' },
                { jp: '「運命石の扉の選択」', cn: '「命运石之门的选择」', char: '冈部伦太郎' },
                { jp: '「失敗した失敗した」', cn: '「失败了失败了」', char: '桥田至' },
                { jp: '「これはステルスマーケティングではない」', cn: '「这才不是隐性营销」', char: '冈部伦太郎' },
                { jp: '「フゥーハッハッハッ！」', cn: '「呼哈哈哈哈哈！」', char: '冈部伦太郎' },
                { jp: '「ドクターペッパー24本」', cn: '「24瓶博士胡椒」', char: '冈部伦太郎' },
                { jp: '「@ちゃんねらー」', cn: '「@频道」', char: '冈部伦太郎' },
                { jp: '「未来ガジェット研究所」', cn: '「未来道具研究所」', char: '通用' },
                { jp: '「Dメール」', cn: '「D-mail（短信）」', char: '通用' },
                { jp: '「タイムリープ」', cn: '「Time Leap（时间跳跃）」', char: '通用' },
                { jp: '「リーディングシュタイナー」', cn: '「Reading Steiner（读取史坦纳/命运探知）」', char: '冈部伦太郎' },
                { jp: '「鳳凰院凶真」', cn: '「凤凰院凶真」', char: '冈部伦太郎（中二化名）' },
                { jp: '「ラボメンナンバー」', cn: '「LabMem编号」', char: '通用' },
                { jp: '「α世界線」', cn: '「α世界线」', char: '通用' },
                { jp: '「まゆしぃは、いつも見てるよ」', cn: '「真由氏，我一直都看着哦」', char: '椎名真由理' },
                { jp: '「世界は欺き続ける」', cn: '「世界将持续欺骗你」', char: '牧濑红莉栖' },
                { jp: '「運命石の扉が閉ざされた」', cn: '「命运石之门已关闭」', char: '冈部伦太郎' },
                { jp: '「世界線を越えて君に会うため」', cn: '「为了跨越世界线与你相见」', char: '冈部伦太郎' },
                { jp: '「β世界線」', cn: '「β世界线」', char: '通用' }
            ],
            monogatari: [
                { jp: '「告白とは、覚悟だ」', cn: '「所谓告白，即是觉悟」', char: '阿良良木历' },
                { jp: '「怪異は、あなた自身だよ」', cn: '「怪异，就是你自己哦」', char: '忍野咩咩' },
                { jp: '「僕の知識は、伊達じゃない」', cn: '「我的知识，绝非虚有其表」', char: '阿良良木历' },
                { jp: '「この世界は、美しくなんかない」', cn: '「这个世界，一点都不美」', char: '战场原黑仪' },
                { jp: '「噛みまみた」', cn: '「我咬碎了哦」', char: '忍野忍' },
                { jp: '「失礼、噛みました」', cn: '「抱歉，我咬下去了」', char: '忍野忍' },
                { jp: '「わざとだ」', cn: '「我是故意的」', char: '战场原黑仪' },
                { jp: '「金がすべてじゃない」', cn: '「金钱并非一切」', char: '神原骏河' },
                { jp: '「ファイヤーシスターズ」', cn: '「Fire Sisters（火焰姐妹）」', char: '八九寺真宵/阿良良木火怜' },
                { jp: '「鬼のお兄ちゃん」', cn: '「鬼哥哥」', char: '阿良良木月火' },
                { jp: '「忍野メメ」', cn: '「忍野咩咩」', char: '忍野咩咩（角色名）' },
                { jp: '「心理戦でも負けてる」', cn: '「就算是心理战我也输了」', char: '阿良良木历' },
                { jp: '「やれやれ」', cn: '「真是的」', char: '忍野咩咩' },
                { jp: '「蝸牛的な」', cn: '「像蜗牛一样」', char: '八九寺真宵' },
                { jp: '「専門家じゃないから」', cn: '「因为我不是专家嘛」', char: '忍野咩咩' },
                { jp: '「幸せって、選ぶものだよ」', cn: '「幸福啊，是需要选择的哦」', char: '阿良良木历' },
                { jp: '「俺は俺であり続ける」', cn: '「我会一直做我自己」', char: '阿良良木历' },
                { jp: '「忘れられることは、忘れてしまえばいい」', cn: '「能够忘记的事情，忘掉就好」', char: '八九寺真宵' },
                { jp: '「君のことを、好きになってもいいですか？」', cn: '「我可以喜欢上你吗？」', char: '千石抚子' },
                { jp: '「怪異とは、心の歪みだ」', cn: '「所谓怪异，是内心的扭曲」', char: '忍野咩咩' }
            ],
            whiteAlbum2: [
                { jp: '「秋深し 情けは人の ためならず」', cn: '「梦里不觉秋已深，余情岂是为他人」', char: '冬马和纱' },
                { jp: '「俺のために、ずっと役立たずでいてくれ。俺が頑張れるように、一生、俺の負担になってくれ」', cn: '「为了我，你就永远当个废物吧；为了能让我好好努力，就一生，都成为我的负担吧」', char: '北原春希' },
                { jp: '「最初は俺が先だったんだ…キスも、抱きしめも、あの人を好きになるのも」', cn: '「是我，是我先，明明都是我先来的……接吻也好，拥抱也好，还是喜欢上那家伙也好」', char: '冬马和纱' },
                { jp: '「どうしてそんなに慣れているんだよ！雪菜といくつキスしたんだよ！？どれだけ俺を遠ざければ気が済むんだよ！？」', cn: '「为什么你会这么熟练啊！你和雪菜亲过多少次了啊！？你到底要把我甩开多远你才甘心啊！？」', char: '冬马和纱' },
                { jp: '「どうして、こうなるんだろう…初めて、好きな人ができた。一生ものの友だちができた。嬉しいことが二つ重なって。その二つ嬉しさが、また、たくさんの嬉しさを連れてきてくれて。夢のように幸せな時間を手に入れたはずなのに…なのに、どうして、こうなっちゃうんだろう…」', cn: '「为什么会变成这样呢……第一次有了喜欢的人。有了能做一辈子朋友的人。两件快乐事情重合在一起。而这两份快乐，又给我带来更多的快乐。得到的，本该是像梦境一般幸福的时间……但是，为什么，会变成这样呢……」', char: '小木曾雪菜' },
                { jp: '「雪菜を選ぶ理由は他にない。世界中の誰よりも、彼女を愛しているから」', cn: '「我选择雪菜的理由不为别的。因为比起世界上任何一个人，我都更爱她」', char: '北原春希' },
                { jp: '「『WHITE ALBUM』なんて、もうどうでもいい。歌うべき歌が、もうないから」', cn: '「白色相簿什么的，已经无所谓了。因为已经不再有歌，值得去唱了」', char: '小木曾雪菜' },
                { jp: '「届かない恋什么的、いらない。愛すべき人が、もういないから」', cn: '「传达不了的恋情，已经不需要了。因为已经不再有人，值得去爱了」', char: '小木曾雪菜' },
                { jp: '「私、裏切っちゃった。次は、あなただけだ」', cn: '「我，已经背叛了，接下来，就只剩你了」', char: '北原春希' },
                { jp: '「あなたの治せる人を治せばいい。私の傷…もうあなたには治せない」', cn: '「你就把你能治好的人给治好吧。我的伤…已经不是你能治疗的了」', char: '小木曾雪菜' },
                { jp: '「なぜ、また私の前に現れたんだ？なぜ、私をそばにいさせたんだ？なぜ、わかりにくいことを言うんだ？」', cn: '「为什么，还要出现在我的面前？为什么，同意我呆在你身边？为什么，总是说些不清不楚的话？」', char: '冬马和纱' },
                { jp: '「先に私の前から消えたのはあなたでしょ！？手の届かない場所に勝手に行ったのはあなたでしょ！」', cn: '「先从我眼前消失的是你吧！？擅自跑到我无法触及的地方去的人是你吧！」', char: '冬马和纱' },
                { jp: '「雪が怖いんだ。とても美しいから、怖いんだ」', cn: '「我害怕雪，因为很美丽，所以我害怕」', char: '北原春希' },
                { jp: '「約束をしたら、依存しちゃうから」', cn: '「因为，一旦做下约定，我就会去依赖它」', char: '小木曾雪菜' },
                { jp: '「わたしの、世界で一番大事な宝物…ずっと持っていると、最後には壊れちゃうから」', cn: '「我的，对我来说世界上最重要的宝物…一直被我拿着的话会最终坏掉的」', char: '冬马和纱' },
                { jp: '「わたし、わがままなことを言っても、必死に実現してくれる人が、大好きです」', cn: '「而能够拼命实现我那因为任性而提出来事情的人，我好喜欢，最喜欢了」', char: '小木曾雪菜' },
                { jp: '「野良犬って…心を開けば、どうしようもなくなっちゃうんですよ」', cn: '「弃犬啊……一旦展开心扉以后，就会变得不知所措了哦」', char: '冬马和纱' },
                { jp: '「春希くんのこと、好きになってもいいですか？」', cn: '「我可以喜欢上春希君吗？」', char: '小木曾雪菜' },
                { jp: '「三人で演じ続けることで、お互いのそばにいられるんだ」', cn: '「我们只有不断地演戏，才能够留在彼此的身边」', char: '和泉千晶' },
                { jp: '「春は来るから、全部元通りになるよ」', cn: '「到了春天，一切都会恢复原样的」', char: '和泉千晶' }
            ],
            saenaiHeroine: [
                { jp: '「お前が俺のヒロインになれ」', cn: '「你要成为我的女主角才行啊！」', char: '安艺伦也' },
                { jp: '「今の私で、あなたの描きたいヒロインになれますか？」', cn: '「现在的我，能不能成为你渴望塑造的女主角呢？」', char: '加藤惠' },
                { jp: '「遠いのは距離じゃない、次元だよ」', cn: '「远的不是距离，而是次元啊」', char: '安艺伦也' },
                { jp: '「なぜ三次元の女に告白しなきゃいけないんだ？」', cn: '「我为什么一定要向三次元的女生表白？」', char: '安艺伦也' },
                { jp: '「お前はまだ、本当に作りたいものが何か分かってないな」', cn: '「看样子，你还没有搞清楚，自己真正想要创造的东西究竟是什么吧」', char: '霞之丘诗羽' },
                { jp: '「調教が必要だな、倫理くん」', cn: '「看来你需要调教啊，伦理君！」', char: '霞之丘诗羽' },
                { jp: '「作家は恋をしてはいけないの？ファンに本気になってはいけないの？」', cn: '「作家难道就不能恋爱吗？作家难道就不能对粉丝动真情吗？」', char: '霞之丘诗羽' },
                { jp: '「お願いがある…俺を男にして…いや！作家にしてくれ！」', cn: '「我有一事相求……让我，让我成为男人……不对！让我成为创作者吧！」', char: '安艺伦也' },
                { jp: '「面白いものをつまらないと言えない」', cn: '「我没办法把有趣的东西说成无聊」', char: '安艺伦也' },
                { jp: '「真剣になったオタクの本当の実力を甘く見るな」', cn: '「别小看认真起来的宅的真正实力啊」', char: '安艺伦也' },
                { jp: '「がんばって、倫也くん。みんなにうらやましい幸せなヒロインにしてね」', cn: '「加油哦，伦也君，要让我成为令众人羡慕的幸福女主角哦！」', char: '加藤惠' },
                { jp: '「一緒に働いた仲間じゃないの？何でも話し合えるじゃないの？」', cn: '「大家是同伴吧？是朋友吧？什么事都应该一起商量才对吧？」', char: '加藤惠' },
                { jp: '「あなた、二次元に対して恥ずかしさが全然ないんですね」', cn: '「你对二次元真是没有半点羞耻心啊」', char: '加藤惠' },
                { jp: '「俺は受け入れるつもりはない。ただずっと待たせるのが可哀想だから」', cn: '「我可没有接受的打算，只是让你一直等下去有点于心不忍而已」', char: '泽村·斯潘塞·英梨梨' },
                { jp: '「俺一人じゃ何もできないって分かってるから、ちょっとだけ手伝ってもいい」', cn: '「我知道你一个人的话什么也办不到，所以我想稍微帮帮你也可以，只帮一点点……」', char: '泽村·斯潘塞·英梨梨' },
                { jp: '「お前の中で一番になる、見せてやる！その前に、絶対に…」', cn: '「我要当……你心中的第一名，我要当给你看！在那之前，我绝对……」', char: '泽村·斯潘塞·英梨梨' },
                { jp: '「いいものは褒め、悪いものは罵る。その眼力と勇気が必要だ」', cn: '「好的就要夸，差的就要骂，你必须要有这种眼光和勇气才行」', char: '霞之丘诗羽' },
                { jp: '「自分のバカな考えは、自分で責任を負え」', cn: '「自己的白痴想法，自己负责到底吧！」', char: '霞之丘诗羽' },
                { jp: '「エロゲーには二つのルールがある。一つはヒロインが可愛いこと、もう一つはルールに束縛されないこと」', cn: '「Galgame有两个规矩，一个是女主角要可爱，另一个是不能被规矩所束缚」', char: '安艺伦也' },
                { jp: '「今年の夏、俺は運命に出会った」', cn: '「今年的这个夏天，我邂逅了我的命运」', char: '安艺伦也' }
            ],
            jojo: [
                { jp: '「人間の賛歌は勇気の賛歌だ」', cn: '「人类的赞歌就是勇气的赞歌」', char: '乔纳森·乔斯达' },
                { jp: '「俺は人間をやめるぞ！ジョースター！」', cn: '「我不做人了！乔斯达！」', char: '迪奥·布兰度' },
                { jp: '「われわれは石仮面の謎を追い求める者たちだ」', cn: '「我们是追寻石假面之谜的人」', char: '罗伯特·E·O·史比特瓦根' },
                { jp: '「その目で見ろ！その耳で聞け！その体で感じろ！」', cn: '「用你的眼睛去看！用你的耳朵去听！用你的身体去感受！」', char: '威廉·A·齐贝林' },
                { jp: '「波紋呼吸法！」', cn: '「波纹呼吸法！」', char: '乔纳森·乔斯达/齐贝林' },
                { jp: '「食う寝るはあくまで副業だ」', cn: '「吃饭睡觉都只是副业而已」', char: '乔瑟夫·乔斯达' },
                { jp: '「お前の波紋は、ガキのクソくらいだ」', cn: '「你的波纹，就像小孩的屎一样不值钱」', char: '卡兹' },
                { jp: '「わかったぜ！これが人間の力だ！」', cn: '「我明白了！这就是人类的力量！」', char: '乔瑟夫·乔斯达' },
                { jp: '「オラオラオラオラ！」', cn: '「欧拉欧拉欧拉欧拉！」', char: '空条承太郎' },
                { jp: '「無駄無駄無駄無駄！」', cn: '「木大木大木大木大！」', char: '迪奥·布兰度' },
                { jp: '「スタープラチナ！」', cn: '「白金之星！」', char: '空条承太郎' },
                { jp: '「時を止める！」', cn: '「时间停止！」', char: '空条承太郎/迪奥·布兰度' },
                { jp: '「いいぜ、このハートは燃えてるぜ！」', cn: '「好啊，这颗心正在燃烧啊！」', char: '东方仗助' },
                { jp: '「ただの人間じゃない！」', cn: '「我不是普通人！」', char: '东方仗助' },
                { jp: '「黄金の精神」', cn: '「黄金的精神」', char: '通用' },
                { jp: '「人は…いつでもそこから始められるんだ」', cn: '「人……无论何时都能从那里重新开始」', char: '空条徐伦' },
                { jp: '「自由のために！」', cn: '「为了自由！」', char: '空条徐伦' },
                { jp: '「その運命を、俺が断ち切る！」', cn: '「这份命运，由我来斩断！」', char: '空条承太郎' },
                { jp: '「友達って…いいもんだな」', cn: '「朋友……真是美好的东西啊」', char: '乔瑟夫·乔斯达' },
                { jp: '「人は何かのために生きるものだ」', cn: '「人是为了某种目的而活着的」', char: '乔纳森·乔斯达' }
            ],
            attackOnTitan: [
                { jp: '「俺は…巨人を全部…追い払うんだ！」', cn: '「我要……把巨人全部……驱逐出去！」', char: '艾伦·耶格尔' },
                { jp: '「心臓を捧げよ！」', cn: '「献出心脏！」', char: '调查兵团全员' },
                { jp: '「自由とは何だ？」', cn: '「自由是什么？」', char: '艾伦·耶格尔' },
                { jp: '「俺たちは、鳥籠の中の鳥だった」', cn: '「我们曾是鸟笼中的鸟」', char: '阿尔敏·阿诺德' },
                { jp: '「忘れてはいけない、俺たちが戦う理由を」', cn: '「不能忘记，我们战斗的理由」', char: '艾尔敏·阿诺德' },
                { jp: '「この世界は広いんだ」', cn: '「这个世界很广阔」', char: '艾伦·耶格尔' },
                { jp: '「人は誰でも、一人では生きていけない」', cn: '「没有人能独自活下去」', char: '三笠·阿克曼' },
                { jp: '「お前たちの自由を、俺が取り戻す」', cn: '「你们的自由，由我来夺回」', char: '艾伦·耶格尔' },
                { jp: '「兵長、お願いします！」', cn: '「兵长，拜托了！」', char: '调查兵团成员' },
                { jp: '「その膝を屈めるな！」', cn: '「不要屈膝下跪！」', char: '利威尔·阿克曼' },
                { jp: '「人間の可能性は無限大だ」', cn: '「人类的可能性是无限大的」', char: '埃尔文·史密斯' },
                { jp: '「死んでも、後世に名を残すんだ」', cn: '「就算死，也要在后世留下名字」', char: '让·基尔希斯坦' },
                { jp: '「俺たちは、ただ生きたいだけだ」', cn: '「我们只是想活下去而已」', char: '艾伦·耶格尔' },
                { jp: '「憎しみは、憎しみを生むだけだ」', cn: '「憎恨只会滋生憎恨」', char: '卡露拉·耶格尔' },
                { jp: '「未来は、自分たちの手で作るものだ」', cn: '「未来是靠自己的双手创造的」', char: '埃尔文·史密斯' },
                { jp: '「お前のことを守るために、俺は強くなる」', cn: '「为了保护你，我要变得更强」', char: '三笠·阿克曼' },
                { jp: '「夢は、逃げたら終わるんだ」', cn: '「梦想，逃跑了就结束了」', char: '艾伦·耶格尔' },
                { jp: '「調査兵団の意志は、永遠に続く」', cn: '「调查兵团的意志，永远延续」', char: '利威尔·阿克曼' },
                { jp: '「この壁の外に、自由が待っている」', cn: '「这堵墙的外面，有自由在等待」', char: '艾伦·耶格尔' },
                { jp: '「俺たちは、巨人として生まれたんじゃない」', cn: '「我们并非生来就是巨人」', char: '艾伦·耶格尔' }
            ],
            yourName: [
                { jp: '「まだ会ったことのない君を、探している」', cn: '「我在寻找，尚未谋面的你」', char: '立花泷/宫水三叶' },
                { jp: '「君の名前は」', cn: '「你的名字是」', char: '立花泷' },
                { jp: '「誰？私、誰？」', cn: '「谁？我，是谁？」', char: '宫水三叶' },
                { jp: '「大切な人。忘れたくない人。忘れちゃダメな人」', cn: '「重要的人。不想忘记的人。绝不能忘记的人」', char: '立花泷' },
                { jp: '「一番大切なものを、忘れないように」', cn: '「为了不忘记最重要的东西」', char: '立花泷' },
                { jp: '「カタワレ時」', cn: '「黄昏之时」', char: '通用' },
                { jp: '「三葉、お前は誰だ？」', cn: '「三叶，你到底是谁？」', char: '立花泷' },
                { jp: '「好きだ」', cn: '「我喜欢你」', char: '立花泷' },
                { jp: '「夢を見ているんだ。誰かの夢を」', cn: '「我在做梦。做着某个人的梦」', char: '宫水三叶/立花泷' },
                { jp: '「どこかで一度、会ったことがある気がするんだ」', cn: '「总觉得在哪里见过你」', char: '立花泷/宫水三叶' },
                { jp: '「君の名は…」', cn: '「你的名字…」', char: '立花泷/宫水三叶' },
                { jp: '「私も、覚えてる」', cn: '「我也记得」', char: '宫水三叶' },
                { jp: '「もう一度、会いたい」', cn: '「想要再见一次」', char: '立花泷' },
                { jp: '「結び」', cn: '「结绳」', char: '宫水一叶' },
                { jp: '「時間が…戻るわけないじゃん」', cn: '「时间…怎么可能倒流呢」', char: '立花泷' }
            ]
        };

        // ==========================================
        // 零宽字符集定义（扩展版 - 16种字符，每字符编码4位二进制）
        // ==========================================
        const ZERO_WIDTH = {
            // 原有4种零宽字符（0000-0011）
            SPACE: '\u200B',           // 零宽空格 - 0000
            NON_JOINER: '\u200C',      // 零宽非连接符 - 0001
            JOINER: '\u200D',          // 零宽连接符 - 0010
            NO_BREAK: '\uFEFF',        // 零宽非断空格 - 0011

            // 扩展不可见字符（0100-1111）
            LRM: '\u200E',             // 左至右标记 - 0100
            RLM: '\u200F',             // 右至左标记 - 0101
            LRE: '\u202A',             // 左至右嵌入 - 0110
            RLE: '\u202B',             // 右至左嵌入 - 0111
            PDF: '\u202C',             // 弹出方向格式 - 1000
            LRO: '\u202D',             // 左至右覆盖 - 1001
            RLO: '\u202E',             // 右至左覆盖 - 1010
            WJ: '\u2060',              // 词连接符 - 1011
            INVISIBLE_SEPARATOR: '\u2062',  // 不可见分隔符 - 1100
            INVISIBLE_PLUS: '\u2064',  // 不可见加号 - 1101
            ALM: '\u061C',             // 阿拉伯字母标记 - 1110
            VS16: '\uFE0F'             // 变体选择符16 - 1111
        };

        // 创建查找数组（按索引顺序）
        const ZERO_WIDTH_ARRAY = [
            ZERO_WIDTH.SPACE,           // 0000 = 0
            ZERO_WIDTH.NON_JOINER,      // 0001 = 1
            ZERO_WIDTH.JOINER,          // 0010 = 2
            ZERO_WIDTH.NO_BREAK,        // 0011 = 3
            ZERO_WIDTH.LRM,             // 0100 = 4
            ZERO_WIDTH.RLM,             // 0101 = 5
            ZERO_WIDTH.LRE,             // 0110 = 6
            ZERO_WIDTH.RLE,             // 0111 = 7
            ZERO_WIDTH.PDF,             // 1000 = 8
            ZERO_WIDTH.LRO,             // 1001 = 9
            ZERO_WIDTH.RLO,             // 1010 = 10
            ZERO_WIDTH.WJ,              // 1011 = 11
            ZERO_WIDTH.INVISIBLE_SEPARATOR, // 1100 = 12
            ZERO_WIDTH.INVISIBLE_PLUS,  // 1101 = 13
            ZERO_WIDTH.ALM,             // 1110 = 14
            ZERO_WIDTH.VS16             // 1111 = 15
        ];

        // 反向映射表（用于解码）
        const ZERO_WIDTH_DECODE_MAP = {
            [ZERO_WIDTH.SPACE]: '0000',
            [ZERO_WIDTH.NON_JOINER]: '0001',
            [ZERO_WIDTH.JOINER]: '0010',
            [ZERO_WIDTH.NO_BREAK]: '0011',
            [ZERO_WIDTH.LRM]: '0100',
            [ZERO_WIDTH.RLM]: '0101',
            [ZERO_WIDTH.LRE]: '0110',
            [ZERO_WIDTH.RLE]: '0111',
            [ZERO_WIDTH.PDF]: '1000',
            [ZERO_WIDTH.LRO]: '1001',
            [ZERO_WIDTH.RLO]: '1010',
            [ZERO_WIDTH.WJ]: '1011',
            [ZERO_WIDTH.INVISIBLE_SEPARATOR]: '1100',
            [ZERO_WIDTH.INVISIBLE_PLUS]: '1101',
            [ZERO_WIDTH.ALM]: '1110',
            [ZERO_WIDTH.VS16]: '1111'
        };

        // ==========================================
        // 核心加解密工具函数
        // ==========================================

        /**
         * XOR加密/解密（对称加密）
         */
        function xorEncrypt(text, key) {
            if (!key) return text;
            let result = '';
            for (let i = 0; i < text.length; i++) {
                result += String.fromCharCode(
                    text.charCodeAt(i) ^ key.charCodeAt(i % key.length)
                );
            }
            return result;
        }

        /**
         * Base64编码（处理Unicode）
         */
        function base64Encode(str) {
            try {
                return btoa(unescape(encodeURIComponent(str)));
            } catch (e) {
                return btoa(str);
            }
        }

        /**
         * Base64解码（处理Unicode）
         */
        function base64Decode(str) {
            try {
                return decodeURIComponent(escape(atob(str)));
            } catch (e) {
                return atob(str);
            }
        }

        /**
         * 字符串转二进制
         */
        function stringToBinary(str) {
            return Array.from(new TextEncoder().encode(str))
                .map(b => b.toString(2).padStart(8, '0'))
                .join('');
        }

        /**
         * 二进制转字符串（优化大数据处理）
         */
        function binaryToString(binary) {
            if (!binary || binary.length === 0) return '';

            const bytes = binary.match(/.{1,8}/g);
            if (!bytes || bytes.length === 0) return '';

            try {
                // 分块处理，避免大数组导致的性能问题
                const CHUNK_SIZE = 10000;
                let result = '';

                for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {
                    const chunk = bytes.slice(i, i + CHUNK_SIZE);
                    const byteArray = new Uint8Array(chunk.map(b => parseInt(b, 2)));
                    result += new TextDecoder().decode(byteArray);
                }

                return result;
            } catch (e) {
                console.error('二进制转字符串错误:', e);
                return '';
            }
        }

        /**
         * 二进制转零宽字符（改进版 - 4位编码）
         */
        function binaryToZeroWidth(binary) {
            let result = '';
            // 每4位二进制转为1个零宽字符
            for (let i = 0; i < binary.length; i += 4) {
                const quartet = binary.substr(i, 4).padEnd(4, '0');
                const index = parseInt(quartet, 2);
                result += ZERO_WIDTH_ARRAY[index];
            }
            return result;
        }

        /**
         * 零宽字符转二进制（改进版 - 4位解码）
         */
        function zeroWidthToBinary(zeroWidth) {
            let binary = '';
            for (const char of zeroWidth) {
                if (ZERO_WIDTH_DECODE_MAP[char]) {
                    binary += ZERO_WIDTH_DECODE_MAP[char];
                }
            }
            return binary;
        }

        /**
         * 从文本中提取零宽字符（支持16种扩展字符）
         */
        function extractZeroWidth(text) {
            const zeroWidthRegex = /[\u200B\u200C\u200D\uFEFF\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2060\u2062\u2064\u061C\uFE0F]/g;
            const matches = text.match(zeroWidthRegex);
            return matches ? matches.join('') : '';
        }

        /**
         * 获取指定风格的台词（根据语言模式返回对应文本）
         */
        function getQuotes(styleId, count) {
            let pool;

            // 混合模式：从所有台词库中随机抽取
            if (styleId === 'mixed') {
                pool = [];
                const allCategories = ['attackOnTitan', 'fate', 'eva', 'steins', 'monogatari', 'whiteAlbum2', 'saenaiHeroine', 'jojo', 'yourName'];
                allCategories.forEach(cat => {
                    if (quoteLibrary[cat]) {
                        pool.push(...quoteLibrary[cat]);
                    }
                });
            } else {
                pool = quoteLibrary[styleId] || quoteLibrary.attackOnTitan;
            }

            const shuffled = [...pool].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, Math.min(count, shuffled.length));

            // 根据语言模式返回对应文本
            return selected.map(item => {
                const text = state.language === 'jp' ? item.jp : item.cn;
                return { text, char: item.char };
            });
        }

        /**
         * 获取台词来源标注
         */
        function getQuoteSource(styleId) {
            const sources = {
                'attackOnTitan': '—— 进击的巨人',
                'fate': '—— Fate系列',
                'eva': '—— 新世纪福音战士',
                'steins': '—— 命运石之门',
                'monogatari': '—— 物语系列',
                'whiteAlbum2': '—— 白色相簿2',
                'saenaiHeroine': '—— 路人女主的养成方法',
                'jojo': '—— JOJO的奇妙冒险',
                'yourName': '—— 你的名字',
                'mixed': '—— 番剧台词混合'
            };
            return sources[styleId] || '';
        }

        // ==========================================
        // 主加密函数（零宽字符隐写 + 压缩 + 改进编码）
        // ==========================================
        function encryptWithSteganography(message, password, styleId) {
            try {
                const originalLength = message.length;

                // 🔥 步骤0: LZ-String压缩（新增！）
                const compressed = LZString.compressToUTF16(message);
                const compressedLength = compressed.length;
                const compressionRatio = ((1 - compressedLength / originalLength) * 100).toFixed(1);
                console.log(`📦 压缩: ${originalLength}字符 → ${compressedLength}字符 (节省${compressionRatio}%)`);

                // 步骤1: XOR加密
                const encrypted = xorEncrypt(compressed, password);

                // 步骤2: Base64编码
                const base64 = base64Encode(encrypted);

                // 步骤3: 转为二进制
                const binary = stringToBinary(base64);

                // 🔥 步骤4: 转为零宽字符（4位编码，效率提升100%）
                const zeroWidth = binaryToZeroWidth(binary);
                console.log(`🔠 零宽编码: ${binary.length}位二进制 → ${zeroWidth.length}个零宽字符`);

                // 步骤5: 获取台词
                const chunkSize = Math.ceil(zeroWidth.length / 4);
                const quotesNeeded = Math.max(3, Math.ceil(zeroWidth.length / chunkSize));
                const quotes = getQuotes(styleId, quotesNeeded);

                // 步骤6: 将零宽字符嵌入台词
                let output = '';
                let zeroWidthIndex = 0;
                const source = getQuoteSource(styleId);

                quotes.forEach((quoteObj, i) => {
                    const chunk = zeroWidth.substr(zeroWidthIndex, chunkSize);
                    zeroWidthIndex += chunkSize;

                    // 拼接：台词 + 零宽字符 + 换行
                    output += quoteObj.text + chunk + '\n';

                    // 添加角色名（可选）
                    if (quoteObj.char) {
                        output += `        —— ${quoteObj.char}\n`;
                    }

                    // 添加来源
                    if (source && i === quotes.length - 1) {
                        output += '        ' + source + '\n';
                    }

                    if (i < quotes.length - 1) output += '\n';
                });

                return {
                    success: true,
                    output: output,
                    zeroWidthLength: zeroWidth.length,
                    quotesUsed: quotes.length,
                    originalLength: originalLength,
                    compressedLength: compressedLength,
                    compressionRatio: compressionRatio
                };

            } catch (error) {
                console.error('加密错误:', error);
                return {
                    success: false,
                    error: error.message
                };
            }
        }


        // ==========================================
        // 主解密函数（优化版）
        // ==========================================
        function decryptFromSteganography(stealthMessage, password) {
            try {
                console.log('开始解密，输入长度:', stealthMessage.length);

                // 步骤1: 提取零宽字符
                const zeroWidth = extractZeroWidth(stealthMessage);
                console.log('提取到零宽字符数量:', zeroWidth.length);

                if (!zeroWidth || zeroWidth.length === 0) {
                    return {
                        success: false,
                        error: '未检测到隐藏数据，请确认粘贴的内容正确'
                    };
                }

                // 步骤2: 零宽字符转二进制
                const binary = zeroWidthToBinary(zeroWidth);
                console.log('二进制长度:', binary.length);

                if (!binary || binary.length === 0) {
                    return {
                        success: false,
                        error: '零宽字符解码失败'
                    };
                }

                // 步骤3: 二进制转Base64字符串
                const base64 = binaryToString(binary);
                console.log('Base64长度:', base64.length);

                if (!base64 || base64.length === 0) {
                    return {
                        success: false,
                        error: '二进制转换失败'
                    };
                }

                // 步骤4: Base64解码
                let encrypted;
                try {
                    encrypted = base64Decode(base64);
                    console.log('解码后长度:', encrypted.length);
                } catch (e) {
                    console.error('Base64解码错误:', e);
                    return {
                        success: false,
                        error: 'Base64解码失败: ' + e.message
                    };
                }

                // 步骤5: XOR解密
                let compressed;
                try {
                    compressed = xorEncrypt(encrypted, password);
                    console.log('XOR解密成功，压缩数据长度:', compressed.length);
                } catch (e) {
                    console.error('XOR解密错误:', e);
                    return {
                        success: false,
                        error: 'XOR解密失败，请检查密钥'
                    };
                }

                // 🔥 步骤6: LZ-String解压缩（新增！）
                let message;
                try {
                    message = LZString.decompressFromUTF16(compressed);
                    if (!message) {
                        // 如果解压失败，可能是旧版本未压缩的数据
                        console.warn('解压失败，尝试直接使用数据');
                        message = compressed;
                    } else {
                        console.log('✅ 解压成功，最终消息长度:', message.length);
                    }
                } catch (e) {
                    console.warn('解压缩错误，使用原始数据:', e);
                    message = compressed;
                }

                return {
                    success: true,
                    output: message
                };

            } catch (error) {
                console.error('解密错误:', error);
                return {
                    success: false,
                    error: '解密失败: ' + error.message
                };
            }
        }

        // ==========================================
        // 辅助函数
        // ==========================================
        function getCurrentStyle() {
            return STYLES[state.styleIndex];
        }

        function updateBackground() {
            const style = getCurrentStyle();
            const colorClass = state.mode === 'ENCRYPT' ? style.colorClass : "from-blue-900 via-slate-800 to-gray-900";
            fluidBlob.className = `liquid-blob absolute -top-[50%] -left-[50%] w-[200%] h-[200%] blur-[120px] bg-gradient-to-r mix-blend-screen opacity-50 transition-colors duration-1000 ${colorClass}`;
        }

        // ==========================================
        // 渲染逻辑
        // ==========================================

        // 1. 渲染锁定界面 (LOCKED)
        function renderLocked() {
            const isEncrypt = state.mode === 'ENCRYPT';
            const style = getCurrentStyle();
            const themeColor = isEncrypt ? 'cyan' : 'red';

            // 风格选择器 HTML 生成
            const stylesHtml = STYLES.map((s, idx) => {
                const isSelected = idx === state.styleIndex;
                const opacity = isSelected ? 'opacity-100 scale-110' : 'opacity-40 hover:opacity-80 hover:scale-105';
                const border = isSelected ? `border-white/80 bg-white/10 shadow-[0_0_20px_rgba(255,255,255,0.3)]` : 'border-white/20 bg-black/20';
                const ring = isSelected ? `<div class="absolute -inset-[2px] rounded-full border border-dashed border-white/50 animate-[spin-slow_8s_linear_infinite]"></div>` : '';
                const glowText = isSelected ? 'text-white text-shadow-glow' : 'text-white/50';

                return `
                    <button onclick="selectStyle(${idx})" class="relative group flex flex-col items-center gap-3 transition-all duration-500 ${opacity} ${!isEncrypt ? 'pointer-events-none grayscale opacity-30' : ''}">
                        <div class="relative w-14 h-14 rounded-full flex items-center justify-center border transition-all duration-500 overflow-hidden ${border}">
                            ${isSelected ? `<div class="absolute inset-0 bg-gradient-to-tr ${s.colorClass} opacity-20 animate-pulse"></div>` : ''}
                            <div class="relative z-10 text-white"><i data-lucide="${s.icon}" width="20"></i></div>
                            ${ring}
                        </div>
                        <div class="flex flex-col items-center">
                            <span class="text-[10px] tracking-widest font-bold transition-colors duration-300 ${glowText}">${s.name}</span>
                            <span class="text-[8px] text-white/30 font-mono">${s.sub}</span>
                        </div>
                    </button>
                `;
            }).join('');

            app.innerHTML = `
                <!-- 模式切换 -->
                <div class="absolute top-8 left-8 z-30 transition-all duration-500">
                    <button onclick="toggleMode()" class="text-[10px] tracking-[0.3em] font-mono border border-white/20 px-6 py-2 rounded-full hover:bg-white/10 transition-colors flex gap-4 backdrop-blur-md">
                        <span class="${state.mode === 'ENCRYPT' ? 'text-cyan-400 font-bold' : 'text-white/30'}">ENCRYPT (构造)</span>
                        <span class="text-white/20">|</span>
                        <span class="${state.mode === 'DECRYPT' ? 'text-red-400 font-bold' : 'text-white/30'}">DECRYPT (解析)</span>
                    </button>
                </div>

                <!-- 语言切换 -->
                <div class="absolute top-8 right-8 z-30 transition-all duration-500 flex gap-3">
                    <!-- 分段模式 -->
                    <button onclick="toggleSegmentMode()" class="text-[10px] tracking-[0.2em] font-mono border border-white/20 px-4 py-2 rounded-full hover:bg-white/10 transition-colors flex gap-2 items-center backdrop-blur-md ${state.mode === 'DECRYPT' ? 'opacity-40 pointer-events-none' : ''}">
                        <i data-lucide="split" class="w-3 h-3 ${state.segmentMode ? 'text-green-400' : 'text-white/30'}"></i>
                        <span class="${state.segmentMode ? 'text-green-400 font-bold' : 'text-white/30'}">分段</span>
                    </button>
                    <!-- 语言 -->
                    <button onclick="toggleLanguage()" class="text-[10px] tracking-[0.3em] font-mono border border-white/20 px-6 py-2 rounded-full hover:bg-white/10 transition-colors flex gap-4 backdrop-blur-md ${state.mode === 'DECRYPT' ? 'opacity-40 pointer-events-none' : ''}">
                        <span class="${state.language === 'cn' ? 'text-amber-400 font-bold' : 'text-white/30'}">中文</span>
                        <span class="text-white/20">|</span>
                        <span class="${state.language === 'jp' ? 'text-amber-400 font-bold' : 'text-white/30'}">日本語</span>
                    </button>
                </div>

                <!-- 标题 -->
                <div class="text-center mb-10 space-y-4 animate-fade-in-down">
                    <h1 class="text-4xl md:text-7xl font-light tracking-tighter bloom-text text-transparent bg-clip-text bg-gradient-to-b from-white via-white to-white/50" style="font-family: 'Playfair Display', serif;">
                        Wh1te · <span class="italic font-bold">秘文终端</span>
                    </h1>
                    <div class="flex items-center justify-center gap-6 text-[10px] tracking-[0.4em] text-white/30 font-mono uppercase">
                        <span>エーテル・サイファー</span>
                        <div class="flex gap-1">
                            <span class="w-1 h-1 ${isEncrypt ? 'bg-cyan-500' : 'bg-red-500'} rounded-full animate-ping"></span>
                            <span class="w-1 h-1 ${isEncrypt ? 'bg-cyan-500' : 'bg-red-500'} rounded-full"></span>
                        </div>
                        <span>${isEncrypt ? 'System_Ready' : 'Listening...'}</span>
                    </div>
                </div>

                <!-- 输入矩阵 -->
                <div class="w-full max-w-2xl z-20 px-4">
                    <div class="relative w-full max-w-md mx-auto mb-10 group perspective-1000">
                        <div class="absolute -inset-[1px] bg-gradient-to-r ${isEncrypt ? 'from-cyan-500/20 to-blue-500/20' : 'from-red-500/20 to-orange-500/20'} rounded-lg opacity-50 group-hover:opacity-100 transition duration-700 blur-[1px]"></div>
                        <div class="relative border border-white/10 bg-black/60 backdrop-blur-xl rounded-lg overflow-hidden shadow-2xl transition-all duration-300 group-hover:bg-black/70">
                            <div class="flex items-center justify-between px-4 py-2 border-b border-white/5 bg-white/[0.02]">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="terminal" width="12" class="${isEncrypt ? 'text-cyan-400' : 'text-red-400'}"></i>
                                    <span class="text-[9px] tracking-[0.2em] font-mono uppercase ${isEncrypt ? 'text-cyan-400/80' : 'text-red-400/80'}">
                                        ${isEncrypt ? 'Write_Protocol' : 'Read_Protocol'}
                                    </span>
                                </div>
                                <div class="flex gap-1.5">
                                    <div class="w-1 h-1 rounded-full bg-white/20"></div>
                                    <div class="w-1 h-1 rounded-full bg-white/20"></div>
                                </div>
                            </div>
                            <textarea id="input-text"
                                oninput="handleInput(this.value)"
                                placeholder="${isEncrypt ? '输入想要加密的“现充”文字...' : '在此粘贴需要解析的密文代码...'}"
                                class="w-full h-36 bg-transparent p-5 text-white/90 placeholder-white/20 text-sm font-serif focus:outline-none resize-none leading-loose tracking-wider selection:bg-cyan-500/30 selection:text-cyan-100 transition-colors duration-500 ${!isEncrypt ? 'text-red-100/90' : ''}"
                            >${state.text}</textarea>
                            <div class="absolute bottom-0 left-0 w-full h-[2px] bg-gradient-to-r ${isEncrypt ? 'from-cyan-500/50' : 'from-red-500/50'} to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-500"></div>
                            <div class="absolute bottom-2 right-3 text-[9px] text-white/20 font-mono pointer-events-none">
                                ${isEncrypt ? 'BUFFER' : 'CACHE'}: <span id="char-count">${state.text.length}</span> / 512
                            </div>
                        </div>
                    </div>

                    <!-- 风格选择器 -->
                    <div class="flex flex-col items-center gap-4 mb-8">
                        <!-- 第一行：所有非混合风格 -->
                        <div class="flex justify-center gap-3 max-w-7xl flex-wrap">
                            ${STYLES.filter(s => s.id !== 'mixed').map((s, originalIdx) => {
                // 找到在STYLES数组中的真实索引
                const idx = STYLES.findIndex(style => style.id === s.id);
                const isSelected = idx === state.styleIndex;
                const opacity = isSelected ? 'opacity-100 scale-110' : 'opacity-40 hover:opacity-80 hover:scale-105';
                const border = isSelected ? `border-white/80 bg-white/10 shadow-[0_0_20px_rgba(255,255,255,0.3)]` : 'border-white/20 bg-black/20';
                const ring = isSelected ? `<div class="absolute -inset-[2px] rounded-full border border-dashed border-white/50 animate-[spin-slow_8s_linear_infinite]"></div>` : '';
                const glowText = isSelected ? 'text-white text-shadow-glow' : 'text-white/50';

                return `
                                    <button onclick="selectStyle(${idx})" class="relative group flex flex-col items-center gap-2 transition-all duration-500 ${opacity} ${!isEncrypt ? 'pointer-events-none grayscale opacity-30' : ''}">
                                        <div class="relative w-12 h-12 rounded-full flex items-center justify-center border transition-all duration-500 overflow-hidden ${border}">
                                            ${isSelected ? `<div class="absolute inset-0 bg-gradient-to-tr ${s.colorClass} opacity-20 animate-pulse"></div>` : ''}
                                            <div class="relative z-10 text-white"><i data-lucide="${s.icon}" width="18"></i></div>
                                            ${ring}
                                        </div>
                                        <div class="flex flex-col items-center">
                                            <span class="text-[9px] tracking-widest font-bold transition-colors duration-300 ${glowText}">${s.name}</span>
                                            <span class="text-[7px] text-white/30 font-mono">${s.sub}</span>
                                        </div>
                                    </button>
                                `;
            }).join('')}
                        </div>
                        
                        <!-- 第二行：混合模式 -->
                        <div class="flex justify-center">
                            ${(() => {
                    const idx = STYLES.findIndex(s => s.id === 'mixed');
                    const s = STYLES[idx];
                    const isSelected = idx === state.styleIndex;
                    const opacity = isSelected ? 'opacity-100 scale-110' : 'opacity-40 hover:opacity-80 hover:scale-105';
                    const border = isSelected ? `border-white/80 bg-white/10 shadow-[0_0_20px_rgba(255,255,255,0.3)]` : 'border-white/20 bg-black/20';
                    const ring = isSelected ? `<div class="absolute -inset-[2px] rounded-full border border-dashed border-white/50 animate-[spin-slow_8s_linear_infinite]"></div>` : '';
                    const glowText = isSelected ? 'text-white text-shadow-glow' : 'text-white/50';

                    return `
                                    <button onclick="selectStyle(${idx})" class="relative group flex flex-col items-center gap-2 transition-all duration-500 ${opacity} ${!isEncrypt ? 'pointer-events-none grayscale opacity-30' : ''}">
                                        <div class="relative w-12 h-12 rounded-full flex items-center justify-center border transition-all duration-500 overflow-hidden ${border}">
                                            ${isSelected ? `<div class="absolute inset-0 bg-gradient-to-tr ${s.colorClass} opacity-20 animate-pulse"></div>` : ''}
                                            <div class="relative z-10 text-white"><i data-lucide="${s.icon}" width="18"></i></div>
                                            ${ring}
                                        </div>
                                        <div class="flex flex-col items-center">
                                            <span class="text-[9px] tracking-widest font-bold transition-colors duration-300 ${glowText}">${s.name}</span>
                                            <span class="text-[7px] text-white/30 font-mono">${s.sub}</span>
                                        </div>
                                    </button>
                                `;
                })()}
                        </div>
                    </div>
                </div>

                <!-- 滑块容器 -->
                <div class="relative mt-2 ${state.text.length > 0 ? 'opacity-100' : 'opacity-40 grayscale pointer-events-none'} transition-all duration-700" id="slider-container">
                    <div class="absolute -top-8 left-0 w-full text-center flex justify-center gap-2 text-[9px] tracking-[0.3em] text-white/40 font-mono">
                        <span>${isEncrypt ? 'SYNC_RATE' : 'DECODE_RATE'}</span>
                        <span id="slider-percent" class="${isEncrypt ? 'text-cyan-400' : 'text-red-400'}">0.0%</span>
                    </div>
                    
                    <div id="slider-track" class="relative w-[300px] h-[60px] border border-white/10 bg-black/40 backdrop-blur-xl rounded-full overflow-hidden flex items-center px-1 shadow-inner cursor-pointer select-none">
                        <!-- 进度背景 -->
                        <div id="slider-fill" class="absolute left-0 top-0 bottom-0 bg-gradient-to-r ${isEncrypt ? 'from-cyan-500/10 via-cyan-500/30 to-white/20' : 'from-red-500/10 via-red-500/30 to-white/20'}" style="width: 0%"></div>
                        <!-- 闪光层 -->
                        <div class="absolute inset-0 bg-[linear-gradient(90deg,transparent_0%,rgba(255,255,255,0.1)_50%,transparent_100%)] w-[50%] h-full animate-[shimmer_2s_infinite] pointer-events-none"></div>

                        <div class="absolute inset-0 flex items-center justify-center pointer-events-none z-0">
                            <span id="slider-text" class="text-[10px] tracking-[0.4em] font-bold text-white/40 transition-all duration-500" style="font-family: 'Cinzel', serif;">
                                ${isEncrypt ? 'SLIDE TO RESONATE' : 'SLIDE TO DECRYPT'}
                            </span>
                        </div>

                        <!-- 滑块把手 -->
                        <div id="slider-handle" class="slider-handle relative z-10 w-[52px] h-[52px] rounded-full border border-white/40 shadow-[0_0_15px_rgba(255,255,255,0.2)] flex items-center justify-center backdrop-blur-md" style="transform: translateX(0px)">
                            <i data-lucide="${isEncrypt ? 'fingerprint' : 'unlock'}" width="24" class="text-white drop-shadow-[0_0_8px_rgba(255,255,255,0.8)]"></i>
                        </div>
                    </div>
                </div>
            `;

            // 初始化滑块逻辑
            initSlider();
            lucide.createIcons();
        }

        // 2. 渲染处理界面 (PROCESSING)
        function renderProcessing() {
            const isEncrypt = state.mode === 'ENCRYPT';
            const colorClass = isEncrypt ? 'text-cyan-100' : 'text-red-100';
            const barColor = isEncrypt ? 'bg-cyan-400 shadow-[0_0_10px_cyan]' : 'bg-red-500 shadow-[0_0_10px_red]';
            const bgClass = isEncrypt ? 'bg-cyan-900/20' : 'bg-red-900/20';
            const scanGradient = isEncrypt ? 'via-cyan-500/20' : 'via-red-500/20';

            app.innerHTML = `
                <div class="relative z-50 w-full h-full flex items-center justify-center bg-black/80 backdrop-blur-sm transition-opacity duration-500">
                    <!-- 能量场 -->
                    <div class="absolute inset-0 ${bgClass} animate-pulse-glow"></div>
                    
                    <!-- 扫描线 -->
                    <div class="absolute left-0 w-full h-32 bg-gradient-to-b from-transparent ${scanGradient} to-transparent blur-md animate-[scan-down_1.5s_infinite_ease-in-out]"></div>

                    <div class="relative z-40 flex flex-col items-center">
                        <div class="text-6xl md:text-8xl font-black tracking-tighter ${colorClass} drop-shadow-[0_0_15px_rgba(255,255,255,0.5)] animate-[float_3s_infinite_ease-in-out]">
                            ${isEncrypt ? "SYNCHRO" : "DECODING"}
                        </div>

                        <!-- 进度条 -->
                        <div class="w-64 h-1 bg-white/10 mt-8 rounded-full overflow-hidden relative">
                            <div id="process-bar" class="absolute left-0 top-0 h-full ${barColor}" style="width: 0%"></div>
                        </div>

                        <span class="text-sm font-mono mt-4 tracking-[0.5em] ${isEncrypt ? 'text-cyan-400/70' : 'text-red-400/70'} animate-pulse">
                            ${isEncrypt ? "零宽隐写生成中..." : "隐藏数据解析中..."}
                        </span>
                    </div>
                </div>
            `;

            // 动画进度条
            setTimeout(() => {
                const bar = document.getElementById('process-bar');
                if (bar) {
                    bar.style.transition = 'width 1.4s ease-in-out';
                    bar.style.width = '100%';
                }
            }, 50);

            // 执行实际的加解密逻辑
            const style = getCurrentStyle();
            if (isEncrypt) {
                // 🔥 检测是否使用分段模式
                if (state.segmentMode) {
                    // 分段加密
                    const segments = encryptInSegments(state.text, '', style.id);
                    state.resultData = {
                        success: true,
                        isSegmented: true,
                        segments: segments,
                        totalSegments: segments.length,
                        output: segments.map((s, i) => `\n━━━━━ 第${i + 1}段/${segments.length} (${s.length}字符) ━━━━━\n\n${s.encrypted}`).join('\n\n'),
                        zeroWidthLength: segments.reduce((sum, s) => sum + s.zeroWidthLength, 0)
                    };
                } else {
                    // 常规加密
                    state.resultData = encryptWithSteganography(state.text, '', style.id);

                    // 🔥 压缩率检测，如果<30%且输出>2000字符，提示开启分段
                    if (state.resultData.success &&
                        parseFloat(state.resultData.compressionRatio) < 30 &&
                        state.resultData.output.length > 2000) {
                        state.resultData.compressionWarning = true;
                        state.resultData.warningMessage = `⚠️ 检测到中日文混合内容，压缩率仅${state.resultData.compressionRatio}%，建议开启"分段"模式以便发送`;
                    }
                }
            } else {
                // 解密模式：从隐写中提取
                state.resultData = decryptFromSteganography(state.text, '');
            }

            // 跳转到结果
            setTimeout(() => {
                state.stage = 'RESULT';
                renderResult();
            }, 1500);
        }

        // 3. 渲染结果界面 (RESULT)
        function renderResult() {
            const isEncrypt = state.mode === 'ENCRYPT';
            const style = getCurrentStyle();

            // 使用隐写系统的结果
            const result = state.resultData;
            const isError = !result || !result.success;
            const displayContent = isEncrypt
                ? (result?.output || '加密失败')
                : (result?.output || result?.error || '解密失败');
            const mainQuote = isEncrypt ? style.quote : (isError ? "数据损毁" : "记忆重组完成");
            const subTitle = isEncrypt ? `PROJECT: ${style.name}` : "SYSTEM MESSAGE";
            const mainDesc = isEncrypt ? `"${style.desc}"` : (isError ? "无法解析该时间线的观测数据。" : "“观测到有效的世界线变动，信息已重构。”");

            // 样式类
            const accentColor = isError ? 'text-red-400' : (isEncrypt ? 'text-cyan-300' : 'text-cyan-300');
            const btnColor = isError ? 'bg-red-900' : 'bg-cyan-300';
            const glowText = isError ? 'glow-red' : 'glow-cyan';

            app.innerHTML = `
                <div class="relative z-30 flex flex-col items-center justify-center w-full h-full p-6 md:p-12 animate-[pulse-glow_0.5s_ease-out]">
                    <!-- 返回按钮 -->
                    <button onclick="resetApp()" class="absolute top-8 right-8 text-white/30 hover:text-white transition-colors flex items-center gap-3 group z-50 px-4 py-2 border border-transparent hover:border-white/10 rounded-full">
                        <span class="text-[10px] tracking-widest font-mono">${isEncrypt ? "TERMINATE" : "RETURN"}</span>
                        <div class="w-1.5 h-1.5 bg-white/40 group-hover:bg-red-500 rounded-full transition-colors"></div>
                    </button>

                    <div class="max-w-6xl w-full flex flex-col md:flex-row gap-16 items-center">
                        
                        <!-- 视觉卡片 -->
                        <div class="relative w-full max-w-[380px] aspect-[2/3] group perspective-1000 animate-[float_6s_infinite_ease-in-out]">
                            <div class="absolute inset-0 border border-white/20 bg-black/40 backdrop-blur-xl overflow-hidden shadow-2xl rounded-sm transition-transform duration-500 group-hover:scale-[1.02] group-hover:shadow-[0_0_50px_rgba(255,255,255,0.1)] preserve-3d">
                                <div class="absolute inset-0 bg-gradient-to-br ${style.colorClass} opacity-30 mix-blend-screen group-hover:opacity-40 transition-opacity duration-700"></div>
                                <div class="absolute inset-0 opacity-20 mix-blend-overlay" style="background-image: url('data:image/svg+xml,%3Csvg viewBox=\'0 0 200 200\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cfilter id=\'noiseFilter\'%3E%3CfeTurbulence type=\'fractalNoise\' baseFrequency=\'0.65\' numOctaves=\'3\' stitchTiles=\'stitch\'/%3E%3C/filter%3E%3Crect width=\'100%25\' height=\'100%25\' filter=\'url(%23noiseFilter)\'/%3E%3C/svg%3E');"></div>

                                <div class="absolute top-0 right-4 h-full flex flex-col justify-center pointer-events-none opacity-10">
                                    <div class="text-8xl font-black text-white writing-vertical font-serif tracking-tighter">
                                        ${isEncrypt ? style.id : "DECODED"}
                                    </div>
                                </div>

                                <div class="relative h-full flex flex-col justify-between p-8 z-10">
                                    <div class="flex justify-between items-start">
                                        <div class="text-[9px] tracking-[0.3em] text-white/60 font-mono border-b border-white/20 pb-2">
                                            ${isEncrypt ? "ENCRYPTED_ARTIFACT" : "MEMORY_RESTORED"}
                                        </div>
                                        <div class="w-8 h-8 border border-white/30 rounded-full flex items-center justify-center">
                                            <i data-lucide="${isEncrypt ? style.icon : 'unlock'}" width="14"></i>
                                        </div>
                                    </div>

                                    <div class="space-y-6 text-center">
                                        <div class="relative inline-block">
                                            <h2 class="text-2xl md:text-3xl font-serif font-bold leading-tight text-white drop-shadow-[0_2px_10px_rgba(0,0,0,0.8)] ${isError ? 'text-red-400' : ''}">
                                                ${mainQuote}
                                            </h2>
                                        </div>
                                        <div class="w-12 h-[2px] bg-white/50 mx-auto"></div>
                                        <div class="font-mono text-[10px] text-white/80 tracking-widest break-all bg-black/30 p-4 rounded border border-white/10 max-h-40 overflow-hidden relative">
                                            ${displayContent}
                                            <div class="absolute bottom-0 left-0 w-full h-8 bg-gradient-to-t from-black/60 to-transparent"></div>
                                        </div>
                                    </div>

                                    <div class="flex justify-between items-end text-[9px] font-mono text-white/40">
                                        <div>
                                            <div>STATUS: ${isError ? "FAIL" : "COMPLETE"}</div>
                                            <div>HASH: ${Date.now().toString().slice(-6)}</div>
                                        </div>
                                        <div class="flex gap-0.5">
                                            <div class="w-0.5 h-2 bg-white/40"></div>
                                            <div class="w-0.5 h-4 bg-white/40"></div>
                                            <div class="w-0.5 h-2 bg-white/40"></div>
                                            <div class="w-0.5 h-4 bg-white/40"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- 详情区 -->
                        <div class="w-full md:flex-1 text-left space-y-10">
                            <div class="space-y-4">
                                <div class="flex items-center gap-3">
                                    <div class="h-[1px] w-12 ${isError ? 'bg-red-400/50' : 'bg-cyan-400/50'}"></div>
                                    <h2 class="text-xs font-bold tracking-[0.5em] uppercase ${glowText} ${accentColor}">
                                        ${subTitle}
                                    </h2>
                                </div>
                                <h3 class="text-3xl md:text-4xl font-serif text-white/90 italic leading-relaxed mix-blend-lighten border-l-2 border-white/20 pl-6">
                                    ${mainDesc}
                                </h3>
                            </div>

                            <!-- 输出内容区 -->
                            <div class="bg-black/40 border border-white/10 p-6 rounded-lg backdrop-blur-md relative overflow-hidden group">
                                <div class="absolute top-0 -left-[100%] w-full h-full bg-gradient-to-r from-transparent via-white/5 to-transparent skew-x-12 group-hover:left-[100%] transition-all duration-1000 ease-in-out"></div>
                                <div class="flex justify-between items-center mb-3">
                                    <div class="text-[10px] text-white/40 tracking-widest uppercase">
                                        ${isEncrypt ? (result?.isSegmented ? `分段输出 (${result.totalSegments}段)` : "Stealth Message") : "Restored Content"}
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <span class="text-[10px] font-mono text-white/40">
                                            ${displayContent.length.toLocaleString()} 字符
                                        </span>
                                        <div class="text-[10px] font-mono ${isError ? 'text-red-400' : 'text-green-400'}">
                                            ${isError ? "ERROR" : "VERIFIED"}
                                        </div>
                                    </div>
                                </div>
                                ${result?.compressionWarning ? `
                                    <div class="mb-3 p-3 bg-amber-900/30 border border-amber-500/30 rounded text-[11px] text-amber-300 flex items-center gap-2">
                                        <i data-lucide="alert-triangle" class="w-4 h-4"></i>
                                        <span>${result.warningMessage}</span>
                                        <button onclick="toggleSegmentMode(); resetApp();" class="ml-auto px-3 py-1 bg-amber-500/30 hover:bg-amber-500/50 rounded text-[10px] font-bold transition-colors">
                                            开启分段
                                        </button>
                                    </div>
                                ` : ''}
                                ${result?.isSegmented ? `
                                    <div class="mb-3 p-3 bg-green-900/30 border border-green-500/30 rounded text-[11px] text-green-300 flex items-center gap-2">
                                        <i data-lucide="check-circle" class="w-4 h-4"></i>
                                        <span>已分为 ${result.totalSegments} 段，点击每段下方按钮依次复制</span>
                                        <span id="copy-progress" class="ml-auto text-[10px] font-mono">0/${result.totalSegments}</span>
                                    </div>
                                    <div class="space-y-4 max-h-[500px] overflow-y-auto custom-scrollbar">
                                        ${result.segments.map((seg, idx) => `
                                            <div class="segment-card bg-black/30 border border-white/10 rounded-lg p-4 transition-all hover:border-cyan-500/30" data-segment="${idx}">
                                                <div class="flex justify-between items-center mb-2">
                                                    <span class="text-[10px] font-mono text-cyan-400">第 ${seg.index}/${seg.total} 段</span>
                                                    <div class="flex items-center gap-2">
                                                        <span class="text-[9px] text-white/40">${seg.length} 字符</span>
                                                        <span id="seg-status-${idx}" class="text-[9px] text-white/30">未复制</span>
                                                    </div>
                                                </div>
                                                <div id="seg-content-${idx}" class="font-mono text-[11px] text-cyan-100/60 break-all whitespace-pre-wrap leading-relaxed max-h-32 overflow-hidden relative">
                                                    ${seg.encrypted}
                                                    <div class="absolute bottom-0 left-0 w-full h-6 bg-gradient-to-t from-black/60 to-transparent"></div>
                                                </div>
                                                <button onclick="copySegment(${idx})" id="seg-btn-${idx}" 
                                                    class="mt-3 w-full py-2 px-4 bg-cyan-500/20 hover:bg-cyan-500/40 border border-cyan-500/30 rounded text-[10px] font-bold text-cyan-300 transition-all flex items-center justify-center gap-2">
                                                    <i data-lucide="copy" class="w-3 h-3"></i>
                                                    <span>复制第 ${seg.index} 段</span>
                                                </button>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : `
                                    <div id="copy-target" class="font-mono text-xs text-cyan-100/70 break-all leading-relaxed tracking-wide select-all whitespace-pre-wrap max-h-[600px] overflow-y-auto custom-scrollbar">${displayContent}</div>
                                    ${displayContent.length > 10000 ? '<div class="mt-2 text-[9px] text-amber-400/70">⚠ 大文本已加载，可滚动查看全部内容</div>' : ''}
                                `}
                            </div>

                            <button id="copy-btn" 
                                ${isError ? 'disabled' : ''}
                                class="group relative flex items-center justify-center w-full md:w-auto gap-3 px-10 py-4 ${isError ? 'bg-gray-800 cursor-not-allowed' : 'bg-white'} text-black overflow-hidden transition-colors">
                                <div class="absolute inset-0 ${btnColor} transform scale-x-0 group-hover:scale-x-100 transition-transform origin-left duration-300"></div>
                                <div class="relative flex items-center gap-3 z-10 text-xs font-black tracking-[0.2em] uppercase">
                                    <span id="copy-text-btn">${isEncrypt ? "复制隐写台词" : "复制解析内容"}</span>
                                </div>
                            </button>
                        </div>
                    </div>
                </div>
            `;

            // 绑定复制按钮
            setTimeout(() => {
                const copyBtn = document.getElementById('copy-btn');
                const copyTarget = document.getElementById('copy-target');
                if (copyBtn && copyTarget && !isError) {
                    copyBtn.onclick = function () {
                        navigator.clipboard.writeText(copyTarget.innerText).then(() => {
                            const btnText = document.getElementById('copy-text-btn');
                            if (btnText) {
                                btnText.innerText = "已复制！";
                                setTimeout(() => {
                                    btnText.innerText = isEncrypt ? "复制隐写台词" : "复制解析内容";
                                }, 2000);
                            }
                        });
                    };
                }
            }, 100);

            lucide.createIcons();
        }

        // ==========================================
        // 交互逻辑
        // ==========================================
        function initSlider() {
            const track = document.getElementById('slider-track');
            const handle = document.getElementById('slider-handle');
            const fill = document.getElementById('slider-fill');
            const text = document.getElementById('slider-text');
            const percentDisplay = document.getElementById('slider-percent');

            if (!track || !handle) return;

            let isDragging = false;
            let startX = 0;
            let currentX = 0;
            const maxDrag = 240; // track width (300) - handle width (52) - padding (8) roughly

            function onStart(e) {
                if (state.text.length === 0) return;
                isDragging = true;
                startX = (e.touches ? e.touches[0].clientX : e.clientX) - currentX;
                handle.style.transition = 'none';
            }

            function onMove(e) {
                if (!isDragging) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                let x = clientX - startX;
                x = Math.max(0, Math.min(x, maxDrag));
                currentX = x;

                const progress = x / maxDrag;

                handle.style.transform = `translateX(${x}px)`;
                fill.style.width = `${progress * 100}%`;

                // 文本透明度
                text.style.opacity = Math.max(0, 1 - progress * 2);
                percentDisplay.innerText = `${(progress * 100).toFixed(1)}%`;

                // 颜色变化 (handle background color opacity)
                const alpha = Math.min(progress, 0.8);
                const color = state.mode === 'ENCRYPT' ? `rgba(6,182,212,${alpha})` : `rgba(239,68,68,${alpha})`;
                handle.style.backgroundColor = color;

                if (progress > 0.95) {
                    isDragging = false;
                    onUnlock();
                }
            }

            function onEnd() {
                if (!isDragging) return;
                isDragging = false;
                if (currentX < maxDrag * 0.95) {
                    // Reset
                    currentX = 0;
                    handle.style.transition = 'transform 0.3s ease-out, background-color 0.3s';
                    handle.style.transform = `translateX(0px)`;
                    handle.style.backgroundColor = '';
                    fill.style.width = `0%`;
                    text.style.opacity = 1;
                    percentDisplay.innerText = `0.0%`;
                }
            }

            // Bind events
            handle.addEventListener('mousedown', onStart);
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onEnd);

            handle.addEventListener('touchstart', onStart, { passive: false });
            window.addEventListener('touchmove', onMove, { passive: false });
            window.addEventListener('touchend', onEnd);
        }

        function onUnlock() {
            state.stage = 'PROCESSING';
            renderProcessing();
        }

        // ==========================================
        // 全局操作
        // ==========================================
        function selectStyle(idx) {
            if (state.mode === 'DECRYPT') return;
            state.styleIndex = idx;
            updateBackground();
            renderLocked();
        }

        function toggleMode() {
            state.mode = state.mode === 'ENCRYPT' ? 'DECRYPT' : 'ENCRYPT';
            state.text = '';
            updateBackground();
            renderLocked();
        }

        function toggleLanguage() {
            if (state.mode === 'DECRYPT') return; // 解密模式下不允许切换语言
            state.language = state.language === 'cn' ? 'jp' : 'cn';
            renderLocked();
        }

        function toggleSegmentMode() {
            if (state.mode === 'DECRYPT') return;
            state.segmentMode = !state.segmentMode;
            renderLocked();
        }

        // 分段复制状态追踪
        let copiedSegments = new Set();

        // 分段复制函数
        function copySegment(idx) {
            const result = state.resultData;
            if (!result || !result.segments || !result.segments[idx]) return;

            const segment = result.segments[idx];

            navigator.clipboard.writeText(segment.encrypted).then(() => {
                // 添加到已复制集合
                copiedSegments.add(idx);

                // 更新按钮状态
                const btn = document.getElementById(`seg-btn-${idx}`);
                if (btn) {
                    btn.innerHTML = `<i data-lucide="check" class="w-3 h-3"></i><span>已复制 ✓</span>`;
                    btn.classList.remove('bg-cyan-500/20', 'hover:bg-cyan-500/40', 'border-cyan-500/30', 'text-cyan-300');
                    btn.classList.add('bg-green-500/20', 'border-green-500/30', 'text-green-300');
                    lucide.createIcons();
                }

                // 更新状态标签
                const status = document.getElementById(`seg-status-${idx}`);
                if (status) {
                    status.innerText = '已复制 ✓';
                    status.classList.remove('text-white/30');
                    status.classList.add('text-green-400');
                }

                // 更新卡片样式
                const card = document.querySelector(`[data-segment="${idx}"]`);
                if (card) {
                    card.classList.add('border-green-500/30', 'bg-green-900/10');
                }

                // 更新总进度
                const progress = document.getElementById('copy-progress');
                if (progress) {
                    progress.innerText = `${copiedSegments.size}/${result.totalSegments}`;
                    if (copiedSegments.size === result.totalSegments) {
                        progress.classList.add('text-green-400', 'font-bold');
                        progress.innerText = `全部完成 ✓`;
                    }
                }
            }).catch(err => {
                console.error('复制失败:', err);
                alert('复制失败，请手动选择复制');
            });
        }

        // 分段加密函数
        function encryptInSegments(message, password, styleId, segmentSize = 350) {
            const segments = [];
            const lines = message.split('\n');
            let currentSegment = [];
            let currentLength = 0;

            lines.forEach(line => {
                const lineLength = line.length + 1;
                if (currentLength + lineLength > segmentSize && currentSegment.length > 0) {
                    segments.push(currentSegment.join('\n'));
                    currentSegment = [line];
                    currentLength = lineLength;
                } else {
                    currentSegment.push(line);
                    currentLength += lineLength;
                }
            });

            if (currentSegment.length > 0) {
                segments.push(currentSegment.join('\n').trim());
            }

            const results = [];
            segments.forEach((seg, idx) => {
                if (seg.trim()) {
                    const result = encryptWithSteganography(seg.trim(), password, styleId);
                    if (result.success) {
                        results.push({
                            index: idx + 1,
                            total: segments.length,
                            original: seg,
                            encrypted: result.output,
                            length: result.output.length,
                            zeroWidthLength: result.zeroWidthLength
                        });
                    }
                }
            });

            return results;
        }

        function handleInput(val) {
            state.text = val;
            const count = document.getElementById('char-count');
            const sliderContainer = document.getElementById('slider-container');
            if (count) count.innerText = val.length;

            if (sliderContainer) {
                if (val.length > 0) {
                    sliderContainer.classList.remove('opacity-40', 'grayscale', 'pointer-events-none');
                    sliderContainer.classList.add('opacity-100');
                } else {
                    sliderContainer.classList.add('opacity-40', 'grayscale', 'pointer-events-none');
                    sliderContainer.classList.remove('opacity-100');
                }
            }
        }

        function copyToClipboard(content) {
            navigator.clipboard.writeText(content).then(() => {
                const btnText = document.getElementById('copy-text-btn');
                const originalText = btnText.innerText;
                btnText.innerText = state.mode === 'ENCRYPT' ? "密文已复制" : "内容已复制";
                setTimeout(() => {
                    btnText.innerText = originalText;
                }, 2000);
            });
        }

        function resetApp() {
            state.stage = 'LOCKED';
            state.text = '';
            copiedSegments.clear(); // 重置分段复制状态
            renderLocked();
        }

        // 初始化
        window.onload = function () {
            renderLocked();
            updateBackground();
        };

    </script>
</body>

</html>
